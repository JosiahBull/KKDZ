{"mappings":"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","sources":["src/liedle/script.js"],"sourcesContent":["const dictionary = [\"stare\", \"doing\", \"lucky\", \"frame\", \"ratio\", \"ouija\", \"ready\", \"touch\"]\nconst NUM_ROWS = 8\nconst NUM_COLS = 5\nlet rowIndex = 0\nlet colIndex = 0\nlet isEndGame\n\n// global variables so they can be changed from the tests\nwindow.secretWord = ''\nwindow.lieRate = 0.08\n\nfunction start() {\n\tisEndGame = false\n\tcreateGrid()\n\thideEndSection()\n\tpickSecretWord()\n\thandleInput()\n}\n\n// hide end section containing win/lose UI components\nfunction hideEndSection() {\n\tconst endSection = document.getElementById('end')\n\tendSection.style.visibility = \"hidden\"\n}\n\n// fill the grid with empty tiles\nfunction createGrid() {\n\tconst grid = document.getElementById('grid')\n\tfor (let i = 0; i < NUM_ROWS; i++) {\n\t\tfor (let j = 0; j < NUM_COLS; j++) {\n\t\t\tgrid.appendChild(getTile(i, j))\n\t\t}\n\t}\n}\n\n// creates and returns an empty tile\nfunction getTile(i, j) {\n\tconst tile = document.createElement('div')\n\ttile.classList.add('tile')\n\t// HTML helpers will automatically convert camel case to dashes\n\t// hyphens are not allowed in JavScript names\n\ttile.dataset.rowIndex = i\n\ttile.dataset.colIndex = j\n\ttile.dataset.type = \"empty\"\n\treturn tile\n}\n\n// updates a tile on the grid with a letter and styling\nfunction updateTile(letter, i, j, type) {\n\t// speech marks are required when using querySelector as i & j are both numbers\n\tconst tile = document.querySelector(`[data-col-index=\"${i}\"][data-row-index=\"${j}\"].tile`)\n\ttile.innerHTML = letter\n\ttile.dataset.type = type\n}\n\n// pick a random word from the dictionary\nfunction pickSecretWord() {\n\twindow.secretWord = dictionary[Math.floor(Math.random() * dictionary.length)]\n}\n\n// handles key presses from the user\nfunction handleInput() {\n\tdocument.addEventListener(\"keydown\", function onEvent(e) {\n\t\tif (isEndGame) {\n\t\t\treturn\n\t\t}\n\n\t\tconst key = e.key\n\t\t// regex matches any lowercase or uppercase english letter\n\t\tif (key.length === 1 && e.key.match(/^[a-z]/i)) {\n\t\t\thandleLetter(key)\n\t\t} else if (e.key === \"Enter\") {\n\t\t\thandleEnter()\n\t\t} else if (e.key === \"Backspace\") {\n\t\t\thandleBackspace()\n\t\t}\n\t})\n}\n\n// add the letter to the grid if possible\nfunction handleLetter(letter) {\n\tif (colIndex > NUM_COLS - 1 || rowIndex > NUM_ROWS - 1) {\n\t\treturn\n\t}\n\n\tupdateTile(letter.toUpperCase(), colIndex, rowIndex, \"full\")\n\tcolIndex++\n}\n\n// delete and reset the last tile\nfunction handleBackspace() {\n\tif (colIndex === 0) {\n\t\treturn\n\t}\n\n\tcolIndex--\n\tupdateTile(\"\", colIndex, rowIndex, \"empty\")\n}\n\n// submit a valid word\nfunction handleEnter() {\n\tconst word = getWord()\n\tif (isValidWord(word)) {\n\t\tcolourWord(word)\n\t}\n}\n\nfunction getWord() {\n\tconst tiles = document.querySelectorAll(`[data-type=\"full\"][data-row-index=\"${rowIndex}\"].tile`)\n\tlet word = \"\"\n\tfor (const tile of tiles) {\n\t\tword += tile.innerHTML\n\t}\n\treturn word.toLowerCase()\n}\n\nfunction isValidWord(word) {\n\treturn (word.length == 5 && dictionary.includes(word));\n}\n\nfunction colourWord(word) {\n\tfor (let i = 0; i < NUM_COLS; i++) {\n\t\tconst tile = document.querySelector(`[data-row-index=\"${rowIndex}\"][data-col-index=\"${i}\"].tile`)\n\t\tif (Math.random() <= window.lieRate && word != window.secretWord) {\n\t\t\tcolourLetterFalsely(tile)\n\t\t} else {\n\t\t\tcolourLetter(tile)\n\t\t}\n\t}\n\tcheckEndGame(word)\n}\n\nfunction colourLetter(tile) {\n\tlet index = window.secretWord.indexOf(tile.innerHTML.toLowerCase())\n\tswitch (index) {\n\t\tcase -1:\n\t\t\ttile.dataset.type = \"wrong\"\n\t\t\tbreak\n\t\tcase parseInt(tile.dataset.colIndex):\n\t\t\ttile.dataset.type = \"right\"\n\t\t\tbreak\n\t\tdefault:\n\t\t\ttile.dataset.type = \"right-letter\"\n\t\t\tbreak\n\t}\n}\n\nfunction colourLetterFalsely(tile) {\n\tlet type\n\tlet index = secretWord.indexOf(tile.innerHTML.toLowerCase())\n\t// set the type to one of the incorrect types \n\tswitch (index) {\n\t\tcase -1:\n\t\t\ttype = (Math.random() < 0.5 ? \"right\" : \"right-letter\")\n\t\t\tbreak\n\t\tcase parseInt(tile.dataset.colIndex):\n\t\t\ttype = (Math.random() < 0.5 ? \"wrong\" : \"right-letter\")\n\t\t\tbreak\n\t\tdefault:\n\t\t\ttype = (Math.random() < 0.5 ? \"right\" : \"wrong\")\n\t\t\tbreak\n\t}\n\ttile.dataset.type = type\n}\n\nfunction checkEndGame(word) {\n\tif (word === secretWord) {\n\t\thandleEndGame(/*isWin =*/ true)\n\t} else if (rowIndex >= NUM_ROWS - 1) {\n\t\thandleEndGame(/*isWin =*/ false)\n\t} else {\n\t\t// reset cursor\n\t\tcolIndex = 0\n\t\trowIndex++\n\t}\n}\n\nfunction handleEndGame(isWin) {\n\tconst endSection = document.getElementById('end')\n\tconst endMsg = document.getElementById('end-message')\n\tconst wordReveal = document.getElementById('word-reveal')\n\tif (isWin) {\n\t\tendMsg.innerHTML = \"YOU WIN!\"\n\t\tendMsg.dataset.result = \"win\"\n\t} else {\n\t\tendMsg.innerHTML = \"YOU LOSE\"\n\t\tendMsg.dataset.result = \"lose\"\n\t}\n\twordReveal.innerHTML = `The secret word was ${secretWord.toUpperCase()}`\n\tendSection.style.visibility = \"visible\"\n\tisEndGame = true\n}\n\n\nstart()"],"names":["dictionary","isEndGame","rowIndex","colIndex","getTile","i","j","tile","document","createElement","classList","add","dataset","type","updateTile","letter","querySelector","innerHTML","colourLetter","window","secretWord","indexOf","toLowerCase","parseInt","colourLetterFalsely","Math","random","handleEndGame","isWin","endSection","getElementById","endMsg","wordReveal","result","toUpperCase","style","visibility","lieRate","grid","appendChild","createGrid","floor","length","addEventListener","e","key","match","NUM_COLS","NUM_ROWS","word","tiles","querySelectorAll","getWord","includes","isValidWord","checkEndGame","colourWord","handleEnter"],"version":3,"file":"index.41a7946f.js.map"}